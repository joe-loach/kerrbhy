use std::{
    fmt::Write,
    path::Path,
};

use regex::{
    Captures,
    Regex,
};
use thiserror::Error;
use wgsl_to_wgpu::{
    create_shader_module,
    WriteOptions,
};

#[derive(Debug, Error)]
pub enum Error {
    #[error(transparent)]
    Io(#[from] std::io::Error),
    #[error(transparent)]
    Fmt(#[from] std::fmt::Error),
}

pub fn create_bindings_for(file: impl AsRef<Path>) -> Result<(), Error> {
    let path = file.as_ref();
    assert!(
        path.is_file(),
        "path to create bindings for should be a file"
    );

    println!("cargo:rerun-if-changed={}", path.display());
    let wgsl_source = std::fs::read_to_string(path)?;

    // Generate the Rust bindings and write to a file.
    let mut text = String::new();
    writeln!(&mut text, "#![allow(unused)]")?;
    writeln!(&mut text, "// File automatically generated by build.rs.")?;
    writeln!(&mut text, "// Changes made to this file will not be saved.")?;

    writeln!(&mut text, "use graphics::wgpu;\n")?;

    let file_name = path
        .file_name()
        .unwrap()
        .to_str()
        .expect("failed to convert filename to utf8 string");
    let module = &create_shader_module(
        &wgsl_source,
        file_name,
        WriteOptions {
            derive_bytemuck: true,
            matrix_vector_types: wgsl_to_wgpu::MatrixVectorTypes::Glam,
            ..Default::default()
        },
    )
    .unwrap();

    // make sure wgpu is imported into every module
    let re = Regex::new(r"mod (?<name>\w+) \{").expect("Regex compilation failed");
    let replacement = |caps: &Captures| -> String {
        let mod_name = &caps["name"];
        format!("mod {mod_name} {{\n    use graphics::wgpu;\n")
    };
    let module = replace_all(&re, module, replacement);

    // add the rest of the module
    text += &module;

    // write out the file
    let out_file = path.with_extension("rs");
    std::fs::write(out_file, text.as_bytes()).expect("failed to write WGSL shader module code");

    Ok(())
}

fn replace_all(re: &Regex, haystack: &str, replacement: impl Fn(&Captures) -> String) -> String {
    let mut new = String::with_capacity(haystack.len());
    let mut last_match = 0;
    for caps in re.captures_iter(haystack) {
        let m = caps.get(0).unwrap();
        new.push_str(&haystack[last_match..m.start()]);
        new.push_str(&replacement(&caps));
        last_match = m.end();
    }
    new.push_str(&haystack[last_match..]);
    new
}
