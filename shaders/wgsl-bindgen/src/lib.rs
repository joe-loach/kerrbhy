mod preprocess;

use std::{
    fmt::Write,
    path::Path,
};

use regex::{
    Captures,
    Regex,
};
use thiserror::Error;
use wgsl_to_wgpu::{
    create_shader_module,
    WriteOptions,
};

use crate::preprocess::ShaderBuilder;

#[derive(Debug, Error)]
pub enum Error {
    #[error(transparent)]
    Io(#[from] std::io::Error),
    #[error(transparent)]
    Fmt(#[from] std::fmt::Error),
    #[error("preprocess error")]
    Preprocessing(#[from] preprocess::Error),
    #[error("shader failed to parse")]
    ShaderParse,
    #[error("failed to create shader module")]
    CreateModuleError(#[from] wgsl_to_wgpu::CreateModuleError),
}

/// Create WGPU bindings and preprocess a shader
pub fn build_shader(file: impl AsRef<Path>) -> Result<(), Error> {
    let path = file.as_ref();
    assert!(
        path.is_file(),
        "path to create bindings for should be a file"
    );

    println!("cargo:rerun-if-changed={}", path.display());

    let builder = ShaderBuilder::new(path).build()?;

    // make sure we re-reun for every included file too
    for included in builder.includes() {
        println!("cargo:rerun-if-changed={}", included.display());
    }

    let wgsl_source = builder.wgsl();

    // check the shader before creating the module for better errors
    if let Err(e) = naga::front::wgsl::parse_str(&wgsl_source) {
        e.emit_to_stderr_with_path(&wgsl_source, path);

        return Err(Error::ShaderParse);
    }

    // Generate the Rust bindings and write to a file.
    let mut text = String::new();
    writeln!(&mut text, "#![allow(unused)]")?;
    writeln!(&mut text, "// File automatically generated by build.rs.")?;
    writeln!(&mut text, "// Changes made to this file will not be saved.")?;

    writeln!(&mut text, "use graphics::wgpu;\n")?;

    writeln!(&mut text, "pub static SOURCE: &str = r##\"{}\"##;\n", &wgsl_source)?;

    let file_name = path
        .file_name()
        .unwrap()
        .to_str()
        .expect("failed to convert filename to utf8 string");

    let module = &create_shader_module(
        &wgsl_source,
        file_name,
        WriteOptions {
            derive_bytemuck: true,
            matrix_vector_types: wgsl_to_wgpu::MatrixVectorTypes::Glam,
            ..Default::default()
        },
    )?;

    // make sure wgpu is imported into every module
    let re = Regex::new(r"mod (?<name>\w+) \{").expect("Regex compilation failed");
    let replacement = |caps: &Captures| -> String {
        let mod_name = &caps["name"];
        format!("mod {mod_name} {{\n    use graphics::wgpu;\n")
    };
    let module = replace_all(&re, module, replacement);
    let module = module.replacen(r#"include_str!("shader.wgsl")"#, "SOURCE", 1);

    // add the rest of the module
    text += &module;

    // write out the file
    let out_file = path.with_extension("rs");
    std::fs::write(out_file, text.as_bytes()).expect("failed to write WGSL shader module code");

    Ok(())
}

fn replace_all(re: &Regex, haystack: &str, replacement: impl Fn(&Captures) -> String) -> String {
    let mut new = String::with_capacity(haystack.len());
    let mut last_match = 0;
    for caps in re.captures_iter(haystack) {
        let m = caps.get(0).unwrap();
        new.push_str(&haystack[last_match..m.start()]);
        new.push_str(&replacement(&caps));
        last_match = m.end();
    }
    new.push_str(&haystack[last_match..]);
    new
}
